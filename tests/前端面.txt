跨域
缓存
cookie
http协议
正则
JS的一些特性（原型链、闭包等等）
DOM
事件
ajax
优化
安全（XSS、CSRF等）
项目经验

一面（不是按照这个顺序）
学习前端多久了 - 两个月
笔试题第三题 - 二叉树问题
JS的数据类型
算法题 - 十多个台阶，每次走一步到两步，有多少种情况
redux - 是怎么实现的， 实现过程
操作DOM比较耗费资源，请问怎么减少消耗
简化操作DOM的API或者库
浏览器缓存
VDOM
作用域以及作用域链
上下文执行栈和作用域链的区别
闭包
url输入浏览器地址栏后的过程
http状态码
JS的事件循环机制
事件循环中队列中的事件有先后顺序吗
setTimeout设定为0ms会直接执行吗，如果设置为5s会一定在5s后执行吗
JS延后加载， 怎么缩短JS的加载时间
MVVM的含义
vue怎么做到MVVM和双向数据绑定
React和小程序
脚本执行时的栈的情况
解析HTML的过程
加载JS和CSS会阻塞浏览器的渲染吗
下载JS和CSS会阻塞吗
操作DOM树为什么比操作VDOM树要慢

二面
学习前端多久了
有学习过计算机网络，操作系统，数据结构和算法这些课程吗
url从输入到浏览器显示页面的过程
DNS是怎么解析的
TCP连接是怎么建立的？详细讲下三次握手
三次握手为什么第二次握手时需要发送多一个SYN包
HTTP请求头的组成
HTML文件的解析过程
为什么会生成CSSOM树
CSS没有选择器
为什么生成了CSSOM树这样的结构
加载JS和CSS会阻塞浏览器的渲染吗
假设有一个页面的header有10个link包含CSS，每个下载10s，中间body中有一个div包含所有类，div下面有10个script，每个下载10s，请问下载的时间是多久？
接上题，如果刷新了以后页面加载需要多久
HTTP缓存
Service Worker是什么，操作API是怎么样的过程
Memory Cache是什么，怎么操作
Disk Cache是什么，怎么操作
Push Cache是什么，怎么操作
如果假设都没有命中上述的缓存，确实发送了网络请求，请问TCP连接建立几次
请求过程中session一般时间是多久
请问每个session在服务器如果都是在有效时间内都是存在的吗，假设有20个session，服务器的这些连接在这段时间都是存在的吗


单例模式的实现原理是什么？手写一个？

写一个闭包吧，不用实现功能的那种。
说一下闭包的概念

说一下输入URL到页面显示的过程，越详细越好

手写JS的继承
原型、构造、组合、ES6等等几种我都写了……这个大家百度一下就有，这种题目尽可能要写全

说一下宏任务和微任务有什么区别

那么promise和setTimeout会谁先执行

说一下promise的原生实现

你做过后台是吧，（对，写过一些）那么说一下是怎么保持登陆态的

那么其中token这种方***有什么问题呢？（回答了xss和csrf，其中提到了验证码来解决csrf）

除了验证码，还有什么好的方式呢？（提到了cookie的same-site属性和refer头）

这个same-site你确定是有用的吗？

refer是一定有效的吗？有没有可能被篡改？

xss一般会过滤什么？（尖括号、斜杠）

为什么要过滤尖括号？（可以插入脚本，如)

这两个字符串有什么不同？

1
2
let a ='123';
let b =newString();
写一个节流函数。

说一下垂直居中的方式？父元素和子元素宽度都不一定。
垂直居中有十种方法左右，建议都可以了解一下……虽然我平时开发也只用flex

说一下vue双向绑定实现的原理

手写一个二分查找

手写一个快速排序
解释一下原理

说一下两个项目对你来说挑战更大的
其中有什么难点
其中说到了利用performance监控，那么其中的火焰图是什么？火焰图的y轴是什么，x轴是什么？

实习做的B端项目相对来说难度也没有很高，你在这段实习经历中主要学习到了什么？
1、去理解比较复杂的业务逻辑
2、大型项目中平衡组件化开发和后续迭代
3、组件封装
4、优化和其他小的难度需求
提升速度的具体数据是什么？
有去做页面打开时加载速度的优化吗？（回答C端做过）
怎么去做这种优化？
这些是本地的优化数据，怎么去监测线上用户的打开时间等数据呢？
在实习过程中，你觉得在开发流程上有什么可以优化的以及你做了些什么优化？
你写过原生的内核吗？
你知道这种小程序编译框架的原理吗？
你知道主流框架的区别吗？
写过ts吗？
微软的vs有一个叫依赖注入的，对这个怎么理解的？
es6了解过吗？模块化是怎么实现的？怎么做到变量名之间互不干扰就是模块之间如何保证互不影响，模块化是怎么做到的？
主技术栈是什么？
用过react吗
react和vue有什么区别
react如果更新上级节点，所有子级节点都会更新，要怎么去处理？
对web性能安全有什么了解吗？（主要说了xss和csrf）
我们如果有一个奖励的系统，有一个用户通过第三方疯狂调用我们的接口我们该怎么做？
验证码有哪些格式？
还有什么别的方法吗？
这些都是可以伪造的，有什么别的方法吗？
设计模式用过吗？最熟悉的模式是什么？
说一下单例模式。
说一下订阅发布模式。


http2相对于http1的改进是什么？
那我们如果要把http1换成http2，我们网站需要做一些什么工作呢？
说一下https为什么比http更安全？
为什么要采用非对称加密和对称加密？
主技术栈是vue，用过别的吗？（用过react）
那么从你的角度说一下vue和react的区别？
说一下从底层原理的实现的区别呢？比如你提到了vue的双向绑定，这是怎么实现呢？
http3和http2的区别是什么？
浏览器缓存在性能优化里也是比较重要的一部分，说一下浏览器缓存吧。
那么Etag的作用是什么呢？
后端是怎么设置Etag的呢？
做过富文本编辑器吗？
如果让你来做一个富文本编辑器，你觉得主要用了浏览器的什么功能？
用过canvas吗？
如果让你来做动画，嵌入到我们的网站里，你会有什么方法？


=====================================================
降低请求量：合并资源，减少 HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。
加快请求速度：预解析 DNS，减少域名数，并行加载，CDN 分发。
缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage。
渲染：JS/CSS 优化，加载顺序，服务端渲染，pipeline。
======
图片减少加载量：
懒加载：滚动条监听，滚动条距离浏览器顶高度===图片距离顶部高度
data-src 赋值到src
小图标：font-family iconfont
小图片多：雪碧图 background position； base64
首页请求量多：
CDN(ngix concat 插件合并文件 逻辑打包)；网络缓存
webpack物理打包
代码组件按需加载 babel插件
前端路由懒加载（spa）：react lazy 分割打包 返回promise渲染控制

资源大：
混淆压缩
gzip on ngix

webp 比png 体积小25%
10 500ms 60 3s 7s

打包：不常用包 cache-control：一年 和etag
频繁： cache-control：no cache etag

不在布局信息改变时做 DOM 查询，
使用 csstext,className 一次性改变属性
使用 fragment


手撕：
创建对象的6种方式总结
1、原型链继承，将父类的实例作为子类的原型，他的特点是实例是子类的实例也是父
类的实例，父类新增的原型方法/属性，子类都能够访问，并且原型链继承简单易于实
现，缺点是来自原型对象的所有属性被所有实例共享，无法实现多继承，无法向父类构
造函数传参。
2、构造继承，使用父类的构造函数来增强子类实例，即复制父类的实例属性给子类，
构造继承可以向父类传递参数，可以实现多继承，通过 call 多个父类对象。但是构造继
承只能继承父类的实例属性和方法，不能继承原型属性和方法，无法实现函数服用，每
个子类都有父类实例函数的副本，影响性能
3、实例继承，为父类实例添加新特性，作为子类实例返回，实例继承的特点是不限制
调用方法，不管是 new 子类（）还是子类（）返回的对象具有相同的效果，缺点是实
例是父类的实例，不是子类的实例，不支持多继承
4、拷贝继承：特点：支持多继承，缺点：效率较低，内存占用高（因为要拷贝父类的
属性）无法获取父类不可枚举的方法（不可枚举方法，不能使用 for in 访问到）
5、组合继承：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父
类实例作为子类原型，实现函数复用
6、寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构
造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点
===========================
工厂模式:
function createPerson(name,age,family) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.family = family;
    o.say = function(){
        alert(this.name);
    }
    return o;
}

var person1 =  createPerson("lisi",21,["lida","lier","wangwu"]);   //instanceof无法判断它是谁的实例，只能判断他是对象，构造函数都可以判断出
var person2 =  createPerson("wangwu",18,["lida","lier","lisi"]);
console.log(person1 instanceof Object);
构造函数模式
function Person(name,age,family) {
    this.name = name;
    this.age = age;
    this.family = family;
    this.say = function(){
        alert(this.name);
    }
}
var person1 = new Person("lisi",21,["lida","lier","wangwu"]);
var person2 = new Person("lisi",21,["lida","lier","lisi"]);
console.log(person1 instanceof Object); //true
console.log(person1 instanceof Person); //true
console.log(person2 instanceof Object); //true
console.log(person2 instanceof Person); //true
console.log(person1.constructor);      //constructor 属性返回对创建此对象的数组、函数的引用
原型模式
function Person() {
}

Person.prototype.name = "lisi";
Person.prototype.age = 21;
Person.prototype.family = ["lida","lier","wangwu"];
Person.prototype.say = function(){
    alert(this.name);
};
console.log(Person.prototype);   //Object{name: 'lisi', age: 21, family: Array[3]}

var person1 = new Person();        //创建一个实例person1
console.log(person1.name);        //lisi

var person2 = new Person();        //创建实例person2
person2.name = "wangwu";
person2.family = ["lida","lier","lisi"];
console.log(person2);            //Person {name: "wangwu", family: Array[3]}
// console.log(person2.prototype.name);         //报错
console.log(person2.age);              //21
混合模式（构造函数模式+原型模式）
function Person(name,age,family){
    this.name = name;
    this.age = age;
    this.family = family;
}

Person.prototype = {
    constructor: Person,  //每个函数都有prototype属性，指向该函数原型对象，原型对象都有constructor属性，这是一个指向prototype属性所在函数的指针
    say: function(){
        alert(this.name);
    }
}

var person1 = new Person("lisi",21,["lida","lier","wangwu"]);
console.log(person1);
var person2 = new Person("wangwu",21,["lida","lier","lisi"]);
console.log(person2);
NEW
创建空对象， this指向执行构造函数，新对象——proto——指向构造函数prototype对象，判断对象，是返回
function myNew（）{
	// var obj = {};
	var Constroctor = [].shift.call(arguments);
	var obj = Object.create(Constroctor.prototype) //obj.__proto__ = Constroctor.prototype;
	var result = Constroctor.apply(obj, arguments);
	return result instanceof Object ? result : obj;
}

PROMISE
function myPromise (fn) {
    let val = null, succcallbacks = [], failcallbacks = []
    let data = null, reason = null, status = 'pending'
    
    this.then = function (fulfilled, rejected) {
        if (status === 'pending') {
            succcallbacks.push(fulfilled)
            failcallbacks.push(rejected)
            return this
        } else if (status === 'resolve') {
            fulfilled(data)
        } else {
            rejected(reason)
        }
    }
    function resolve (val) {
        setTimeout(() => {
            data = val
            status = 'fulfilled'
            succcallbacks.forEach((callback) => {
                callback(val)
            })
        }, 0)
    }
    function reject (val) {
        setTimeout(() => {
            reason = val
            status = 'rejected'
            failcallbacks.forEach((callback) => {
                callback(val)
            })
        }, 0)
    }
    fn(resolve, reject)
}
// 测试
function test(num) {
    return new myPromise((resolve, reject) => {
        setTimeout(() => {
            resolve(num)
        }, 1000)
    })
}

BIND
// bind
Function.prototype.bind = function(context){
	let args = [].slice.call(arguments, 1)
	let that = this
	function f(){
		return that.apply(this instanceof f ? this : context, args.concat([].slice.call()))
	}
	f.prototype = Object.create(this.prototype)
	return f;
}
// apply
Function.prototype.apply(context, arg) {
	if(typeof this !== 'function') {
		throw new Error('类型错误')
	}
	context = context || window
	context.func = this
	let result = context.func(...arg)
	delete context.func
	return result
}
// call
Function.prototype.call(context, ...arg) {
	if(typeof this !== 'function') {
		throw new Error('类型错误')
	}
	context = context || window
	context.func = this
	let result = context.func(...arg)
	delete context.func
	return result
}
----------------
instanceof
// instanceof 是通过原型链判断的，即判断构造函数的原型对象是否在 obj 的原型链上
function InstanceOf(obj, Fun){
	let left = onj.__proto__
	let right = Fun.prototype
	while(1){
		if(left === null) {
			return false
		}
		if(left === right){
			return true
		}
		left = left.__proto__
	}
}
// 深拷贝
// 方法1
let newObj = JSON.parse(JSON.stringify(obj))
// 方法2
function deepClone(obj){
	let newObj = Array.isArray(obj) ? [] : {}
	for(let i in obj){
		newObj[i] = typeof obj[i] === 'object' ? deepClone(obj[i]) : obj[i]
	}
	return newObj
}
数组扁平化
1.
flatArr123.flat(Infinity)
2.
function flatten3(arr) {
    return arr.toString().split(',').map(x => +x)
}
3.
function flatten(arr){
	let res = []
	while(arr.length > 0){
		let tmp = arr.pop()
		if(Array.isArray(tmp)){
			arr.push(...tmp)
		}else{
			res.unshift(tmp)
		}
	}
	return res
}

// 节流函数（在规定的时间间隔内只触发一次事件处理函数，如果多次触发，则什么也不做）
function throttle(func, wait){
	let start = Date.now()
	return function(){
		let end = Date.now()
		if(end - start > wait){
			return func.apply(this, arguments)
			start = end
		}
	}
}
// 防抖函数（在规定的时间间隔内只触发一次事件处理函数，如果多次触发则重新设置计时器，即把在规定时间内多次触发的事件合并为一次）
function debounce(func, wait){
	let timer = null
	return function() {
		if(timer !== null){
			clearTimeout(timer)
			timer = null
		}
		timer = setTimeout(() => {
			func.apply(this, arguments)
		}, wait)
	}
}

单例模式
class LoginForm {
    constructor () {
        this.state = 'hide'
    }
    show () {
        if (this.state === 'show') {
            console.log('已经show')
        }
        this.state = 'show'
        console.log('登录框show成功')
    }
    hide () {
        if (this.state === 'hide') {
            console.log('已经hide')
        }
        this.state = 'hide'
        console.log('登录框hide成功')
    }
}

LoginForm.getInstance = (function () {
    let instance = null
    return function () {
        if (!instance) {
            instance = new LoginForm()
        }
        return instance
    }
})()
运用发布订阅者模式
function lazyMan(name) {
    // 任务清单队列
    this.taskList = []
    this.name = name
    console.log(`Hi I am ${name}`)
    setTimeout(() => this.next())
}
lazyMan.prototype = {
    // 订阅方法
    eat (food) {
        const fn = () => {
            console.log(`i am eating ${food}`);
            this.next()
        }
        this.taskList.push(fn)
        return this
    },
    sleepFirst (time) {
        const fn = () => {
            setTimeout(() => {
                console.log(`等待了${time}秒`);
                this.next()
            }, time*1000)
        }
        this.taskList.unshift(fn)
        return this
    },
    sleep (time) {
        const fn = () => {
            setTimeout(() => {
                console.log(`等待了${time}秒`);
                this.next()
            }, time*1000)
        }
        this.taskList.push(fn)
        return this
    },
    // 事件发布
    next () {
        const fn = this.taskList.shift()
        fn && fn()
    }
}
function LazyMan (name) {
    return new lazyMan(name)
}

LazyMan('Tony')
LazyMan('Tony').sleep(10).eat('lunch')
LazyMan('Tony').eat('lunch').sleep(10).eat('dinner')
LazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(10).eat('junk food')

2.
class EventEmitter {
  constructor() {
    this.cache = {};
  }
  on(name, fn) {
    if (this.cache[name]) {
      this.cache[name].push(fn);
    } else {
      this.cache[name] = [fn];
    }
  }
  off(name, fn) {
    let tasks = this.cache[name];
    if (tasks) {
      const index = tasks.findIndex((f) => f === fn || f.callback === fn);
      index >= 0 ? tasks.splice(index, 1) : "";
    }
  }
  emit(name, once, ...args) {
    if (this.cache[name]) {
      // 创建副本
      let tasks = this.cache[name].slice();
      for (const fn of tasks) {
        fn(...args);
      }
      once ? delete this.cache[name] : "";
    }
  }
}

let demo = new EventEmitter();
demo.on("wenbo", function (data) {
  console.log("wenbo", data);
});
let fn1 = function (data) {
  console.log("hello:", data);
};
demo.on("wenbo", fn1);

demo.emit("wenbo", false, "world");
demo.off("wenbo", fn1);
demo.emit("wenbo", false, "world");

//wenbo world
//hello: world

//wenbo world

=============================================
图片加载优化懒加载
//   获取全部img元素 并且将类数组转化成数组
let imgList = [...document.querySelectorAll("img")];
let len = imgList.length;
// 图片懒加载
function imgLazyLoad() {
  let count = 0;
  return (function () {
    let isLoadList = [];
    imgList.forEach((item, index) => {
      let h = item.getBoundingClientRect();
      //  判断图片是否快要滚动道可视区域
      if (h.top < window.innerHeight + 200) {
        item.src = item.dataset.src;
        console.log(item.dataset.src);
        isLoadList.push(index);
        count++;
        // 全部加载 移出scroll事件
        if (len == count) {
          document.removeEventListener("scroll", imgLazyLoad);
        }
      }
    });
    // 移出已经加载完成的图片
    imgList = imgList.filter((img, index) => !isLoadList.includes(index));
  })();
}
// 节流函数
function throttle(fun, wait) {
  var lastTime = 0;
  return function () {
    var _this = this;
    var _arg = arguments;
    var nowTime = new Date().getTime();
    if (nowTime - lastTime > wait) {
      fun.apply(_this, _arg);
      lastTime = nowTime;
    }
  };
}
// 默认执行一次加载首屏图片
imgLazyLoad();
// 节流执行
document.addEventListener("scroll", throttle(imgLazyLoad, 200));
===========================
// 快排排序
function quickSort(arr) {
  // 数组长度为1 直接返回
  if (arr.length <= 1) return arr;
  var left = [],
    right = [];
  var centerIndex = Math.floor(arr.length / 2);
  // 定义中间值
  var center = arr[centerIndex];
  for (let i = 0; i < arr.length; i++) {
    // 小于中间值数据添加到left
    if (arr[i] < center) {
      left.push(arr[i]);
    } else if (arr[i] > center) {
      // 大于中间值数据添加到right
      right.push(arr[i]);
    }
  }
  // 递归返回 concat连接返回数据
  return quickSort(left).concat([center], quickSort(right));
}
// 冒泡排序
function bubbleSort(arr) {
  for (var i = 0; i < arr.length - 1; i++) {
    for (var j = i + 1; j < arr.length; j++) {
      if (arr[i] > arr[j]) {
        var temp = arr[j];
        arr[j] = arr[i];
        arr[i] = temp;
      }
    }
  }
  return arr;
}
=========
二叉树遍历
// 前序遍历
function preorderTraversal(root, arr = []) {
  if (root === null) return
  arr.push(root.val)
  preorderTraversal(root.left, arr)
  preorderTraversal(root.right, arr)
  return arr
}
// 中序遍历
function inorderTraversal(root, arr = []) {
  if (root === null) return
  inorderTraversal(root.left, arr)
  arr.push(root.val)
  inorderTraversal(root.right, arr)
  return arr
}
// 后序遍历
function postorderTraversal(root, arr = []) {
  if (root === null) return
  postorderTraversal(root.left, arr)
  postorderTraversal(root.right, arr)
  arr.push(root.val)
  return arr
}
==========
字符串的全排列
function permutation (str) {
    let res = [str[0]]
    for (let i = 1; i < str.length; i++) {
        res = fp(res, str[i])
    }
    return [...new Set(res)].sort()
}

function fp (arr, ch) {
    let tmp = []
    for (let i = 0; i <= arr[0].length; i++) {
        tmp = tmp.concat(arr.map((x) => x.slice(0, i) + ch + x.slice(i)))
    }
    return tmp
}
// console.log(permutation('abc'));

