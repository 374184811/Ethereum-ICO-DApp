https://wenku.baidu.com/view/b8139fb5d05abe23482fb4daa58da0116d171f51.html
比特币系统的脚本语言存在一些严重的限制：

缺少图灵完备性 – 这就是说，尽管比特币脚本语言可以支持多种计算，但是它不能支持所有的计算。最主要的缺失是循环语句。
不支持循环语句的目的是避免交易确认时出现无限循环。理论上，对于脚本程序员来说，这是可以克服的障碍，
因为任何循环都可以用多次重复if 语句的方式来模拟，但是这样做会导致脚本空间利用上的低效率，例如，
实施一个替代的椭圆曲线签名算法可能将需要256次重复的乘法，而每次都需要单独编码。
价值盲（Value-blindness）。UTXO脚本不能为账户的取款额度提供精细的的控制。例如，预言机合约（oracle contract）的一个强大应用是对冲合约，
A和B各自向对冲合约中发送价值1000美元的比特币，30天以后，脚本向A发送价值1000美元的比特币，向B发送剩余的比特币。
虽然实现对冲合约需要一个预言机（oracle）决定一比特币值多少美元，但是与现在完全中心化的解决方案相比，这一机制已经在减少信任和基础设施方面有了巨大的进步。
然而，因为UTXO是不可分割的，为实现此合约，唯一的方法是非常低效地采用许多有不同面值的UTXO
（例如对应于最大为30的每个k，有一个2^k的UTXO)并使预言机挑出正确的UTXO发送给A和B。
缺少状态 – UTXO只能是已花费或者未花费状态，这就没有给需要任何其它内部状态的多阶段合约或者脚本留出生存空间。
这使得实现多阶段期权合约、去中心化的交换要约或者两阶段加密承诺协议（对确保计算奖励非常必要）非常困难。这也意味着UTXO只能用于建立简单的、一次性的合约，
而不是例如去中心化组织这样的有着更加复杂的状态的合约，使得元协议难以实现。二元状态与价值盲结合在一起意味着另一个重要的应用-取款限额-是不可能实现的。
区块链盲（Blockchain-blindness）- UTXO看不到区块链的数据，例如随机数和上一个区块的哈希。这一缺陷剥夺了脚本语言所拥有的基于随机性的潜在价值，
严重地限制了博彩等其它领域应用。
===========================

UTXO 模型
优点：
计算是在链外的，交易本身既是结果也是证明。节点只做验证即可，不需要对交易进行额外
的计算，也没有额外的状态存储。交易本身的输出 UTXO 的计算是在钱包完成的，这样交易
的计算负担完全由钱包来承担，一定程度上减少了链的负担。
除 Coinbase 交易外，交易的 Input 始终是链接在某个 UTXO 后面。交易无法被重放，
并且交易的先后顺序和依赖关系容易被验证，交易是否被消费也容易被举证。
UTXO 模型是无状态的，更容易并发处理。
对于 P2SH 类型的交易，具有更好的隐私性。交易中的 Input 是互不相关联的，可以使用 
CoinJoin 这样的技术，来增加一定的隐私性。
缺点：
无法实现一些比较复杂的逻辑，可编程性差。对于复杂逻辑，或者需要状态保存的合约，
实现难度大，且状态空间利用率比较低。
当 Input 较多时，见证脚本也会增多。而签名本身是比较消耗 CPU 和存储空间的。
=========================================================
ACCOUNT 模型
对于 Account 模型，Account 模型保存了世界状态，链的状态一般在区块中以 StateRoot 
和 ReceiptRoot 等形式进行共识。交易只是事件本身，不包含结果，交易的共识和状态的
共识本质上可以隔离的。
优点：

合约以代码形式保存在 Account 中，并且 Account 拥有自身状态。这种模型具有更好的可编程性，容易开发人员理解，场景更广泛。
批量交易的成本较低。设想矿池向矿工支付手续费，UTXO 中因为每个 Input 和 Out 都需要单独 Witness script 或者 Locking script，
交易本身会非常大，签名验证和交易存储都需要消耗链上宝贵的资源。而 Account 模型可以通过合约的方式极大的降低成本。
缺点：

Account 模型交易之间没有依赖性，需要解决重放问题。
对于实现闪电网络/雷电网络，Plasma 等，用户举证需要更复杂的 Proof 证明机制，子链向主链进行状态迁移需要更复杂的协议。
===================================================
UTXO VS ACCOUNT
对于以上几个优点和缺点，我们再做一些分析和对比。

第一，关于计算的问题。

UTXO 交易本身对于区块链并没有复杂的计算，这样简单的讲其实并不完全准确，原因分有两个，一是 Bitcoin 本身的交易多为 P2SH，
且 Witness script 是非图灵完备的，不存在循环语句。而对于 Account 模型，例如 Ethereum，由于计算多在链上，且为图灵完备，
一般计算较为复杂，同时合约安全性就容易成为一个比较大的问题。当然是否图灵完备对于是否是账户模型并没有直接关联。
但是账户模型引入之后，合约可以作为一个不受任何人控制的独立实体存在，这一点意义重大。

第二，关于 UTXO 更易并发的问题。

在 UTXO 模型中，世界状态即为 UTXO 的集合，节点为了更快的验证交易，需要在内存中存储所有的 UTXO 的索引，因此 UTXO 是非常昂贵的。
对于长期不消费的 UTXO，会一直占用节点的内存。所以对于此种模型，理论上应该鼓励用户减少生产 UTXO，多消耗 UTXO。
但是如果要使用 UTXO 进行并行交易则需要更多的 UTXO 作为输入，同时要产生更多的 UTXO 来保证并发性，这本质上是对网络进行了粉尘攻击。
并且由于交易是在钱包内构造，所以需要钱包更复杂的设计。反观 Account 模型，每个账户可以看成是单独的互不影响的状态机，账户之间通过消息进行通信。
所以理论上用户发起多笔交易时，当这些交易之间不会互相调用同一 Account 时，交易是完全可以并发执行的。

第三，关于 Account 模型的交易重放问题。

Ethereum 使用了在 Account 中增加 nonce 的方式，每笔交易对应一个 nonce，nonce 每次递增。这种方式虽然意在解决重放的问题，
但是同时引入了顺序性问题，同时使得交易无法并行。例如在 Ethereum中，用户发送多笔交易，如果第一笔交易打包失败，
将引起后续多笔交易都打包不成功。在 CITA 中我们使用了随机 nonce 的方案，这样用户的交易之间没有顺序性依赖，不会引起串联性失败，同时使得交易有并行处理的可能。

第四，存储问题。

因为 UTXO 模型中，只能在交易中保存状态。而 Account 模型的状态是在节点保存，在 Ethereum 中使用 MPT 的方式存储，
Block 中只需要共识 StateRoot 等即可。这样对于链上数据，Account 模型实际更小，网络传输的量更小，同时状态在节点本地使用 MPT 方式保存，
在空间使用上也更有效率。例如 A 向 B 转账，如果在 UTXO 中假设存在 2 个 Input 和2个 Output，则需要 2 个 Witness script 和 2 个 Locking script；
在 Account 模型中则只需要一个签名，交易内容只包含金额即可。在最新的隔离见证实现后，Bitcoin 的交易数据量也大大减少，
但是实际上对于验证节点和全节点仍然需要针对 Witness script 进行传输和验证。

第五，对于轻节点获取某一地址状态，UTXO 更复杂。

例如钱包中，需要向全节点请求所有关于某个地址的所有 UTXO，全节点可以发送部分 UTXO，钱包要验证该笔 UTXO 是否已经被消费，有一定的难度，
而且钱包很难去证明 UTXO 是全集而不是部分集合。而对于 Account 模型则简单很多，根据地址找到 State 中对应状态，
当前状态的 State Proof 则可以证明合约数据的真伪。当然对于 UTXO 也可以在每个区块中对 UTXO 的 root 进行验证，
这一点与当前 Bitcoin 的实现有关，并非 UTXO 的特点。

结论
综上来看，Account 模型在可编程性，灵活性等方面更有优势；在简单业务和跨链上，UTXO 有其非常独到和开创性的优点。
对于选择何种模型，要从具体的业务场景进行出发。


========================================
交易
要想和区块链进行交互，你需要发送一笔交易。一笔交易由少数几部分组成，我喜欢用巨慢无比的邮件来类比：

目标地址：交易发送到的目标以太坊地址。可以是另一个人或一个智能合约。你可以将它想象成写在信封正面的收件地址。
价值：这就像在信封里放一丢丢现金给收件人。
数据：这就像你寄出的信件上的内容。当你只发送价值时，这部分通常是空的。
Nonce（流水号）：由于你发送的内容都是数字信息，因此可能被复制。为了防止同一封信被寄了两次，我们会跟踪一个计数。
这有点像信封本身的标识。（另一个关于 nonce 的形象比喻是支票号码。从技术上讲，银行不应该兑现最后一张现金支票之前的一张现金支票）
Gas Price：这就像是你放在邮箱中的一些零钱，用来激励邮递员为你送信。你放的零钱越多，邮递员取走你信件的可能性就越高。
Gas Limit：这就像邮递员送信的最远距离的限制。假设他最终要去地球的另一边为你送信，这意味着他要绕过重重阻碍……你当然希望避免这种情况，因为你要为他的行程买单。
签名：最终，我们把上面的数据都汇总在一起并进行哈希运算、用你（对哈希值）的签名来封好信封，该签名证明里面的内容都经过了你的验证。
============================================
EVM
Storage memory stack
========================
我国公开的主要国密算法包括ZUC祖冲之算法、SM2、SM3、SM4、SM9五种，分别为流密码、非对称密码、散列算法、分组对称密码和非对称标识密码
RC4;RSA,ECDSA;SHA256,MD5;DES,3DES;...
https://blog.csdn.net/lwzhang1101/article/details/78773700
==========================
根据top命令，发现PID为28555的Java进程占用CPU高达200%，出现故障。
通过ps aux | grep PID命令，可以进一步确定是tomcat进程出现了问题。但是，怎么定位到具体线程或者代码呢？
ps -mp pid -o THREAD,tid,time
jstack pid |grep tid -A 30
排查CPU故障的方法和技巧有哪些：
1、top命令：Linux命令。可以查看实时的CPU使用情况。也可以查看最近一段时间的CPU使用情况。
2、PS命令：Linux命令。强大的进程状态监控命令。可以查看进程以及进程中线程的当前CPU使用情况。属于当前状态的采样数据。
3、jstack：Java提供的命令。可以查看某个进程的当前线程栈运行情况。根据这个命令的输出可以定位某个进程的所有线程的当前运行状态、运行代码，以及是否死锁等等。
4、pstack：Linux命令。可以查看某个进程的当前线程栈运行情况。
